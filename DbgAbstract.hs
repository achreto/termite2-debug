{-# LANGUAGE ImplicitParams, RecordWildCards #-}

module DbgAbstract (abstractState,
                    abstractUntracked,
                    abstractLabel,
                    abstractTransition) where

import qualified Data.Map as M

import Util hiding (trace)
import qualified DbgTypes as D
import IExpr
import ISpec
import IVar
import Predicate
import Store
import qualified Implicit as Imp

abstractRel :: (D.Rel c v a s, ?spec::Spec, ?m::c, ?absvars::M.Map String AbsVar) => [D.ModelVar] -> Store -> a
abstractRel vars store = Imp.conj $ map (evalAbsVar store) vars

abstractState :: (D.Rel c v a s, ?spec::Spec, ?m::c, ?model::D.Model c a Store, ?absvars::M.Map String AbsVar) => Store -> D.State a Store
abstractState store = D.State { D.sAbstract = abstractRel (D.mCurStateVars ?model) store
                              , D.sConcrete = Just $ storeProject store $ map varName $ specStateVar ?spec
                              }

abstractUntracked :: (D.Rel c v a s, ?spec::Spec, ?m::c, ?model::D.Model c a Store, ?absvars::M.Map String AbsVar) => Store -> a
abstractUntracked = abstractRel (D.mUntrackedVars ?model)

abstractLabel :: (D.Rel c v a s, ?spec::Spec, ?m::c, ?model::D.Model c a Store, ?absvars::M.Map String AbsVar) => Store -> a
abstractLabel = abstractRel (D.mLabelVars ?model)

abstractTransition :: (D.Rel c v a s, ?spec::Spec, ?m::c, ?model::D.Model c a Store, ?absvars::M.Map String AbsVar) => D.State a Store -> Store -> D.Transition a Store
abstractTransition from to = D.Transition {
        tranFrom = from,
        -- compute untracked and label predicates over to
        tranUntracked     = abstractUntracked $ fromJustMsg "abstractTransition: no concrete state" $ D.sConcrete from,
        tranAbstractLabel = abstractLabel     to,
        -- project "to" state on "tmp" variables
        tranConcreteLabel = Just $ storeProject to (map varName $ specTmpVar ?spec),
        tranTo            = abstractState to
    }


evalAbsVar :: (D.Rel c v a s, ?spec::Spec, ?m::c, ?absvars::M.Map String AbsVar) => Store -> D.ModelVar -> a
evalAbsVar store D.ModelVar{..} = 
    -- .en variables that are generated by the abstractor and are unknown 
    -- to the debugger must be handled in a special way: set the .en variable
    -- to true iff the base variable is assigned
    case M.lookup mvarName ?absvars of
         Nothing -> if D.isEnVarName mvarName
                       then case M.lookup (D.mkBaseVarName mvarName) ?absvars of
                                 Nothing -> error $ "evalAbsVar: unknown .en variable " ++ mvarName
                                 Just v  -> case storeTryEval store (avarToExpr v) of
                                                 Nothing -> Imp.eqConst (D.idxToVS mvarIdx) (0::Int)
                                                 _       -> Imp.eqConst (D.idxToVS mvarIdx) (1::Int) 
                       else error $ "evalAbsVar: unknown abstract variable " ++ mvarName
         Just v  -> evalAbsVar' store v mvarIdx

-- var not in store <-> no constraint
evalAbsVar' :: (D.Rel c v a s, ?spec::Spec, ?m::c) => Store -> AbsVar -> [Int] -> a
evalAbsVar' store avar is = 
    case storeTryEvalScalar store $ avarToExpr avar of
         Just v   -> Imp.eqConst (D.idxToVS is) (scalarToInt v)
         Nothing  -> Imp.t

scalarToInt :: (?spec::Spec) => Val -> Integer
scalarToInt (BoolVal True)  = 1
scalarToInt (BoolVal False) = 0
scalarToInt (UIntVal _ i)   = i
scalarToInt (SIntVal _ i)   = i
scalarToInt (EnumVal   s)   = fromIntegral $ enumToInt s
